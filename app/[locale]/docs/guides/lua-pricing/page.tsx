"use client";

import { useLocale } from "next-intl";

const content = {
  en: {
    title: "Pool Pricing & Candles with Lua",
    intro: "Learn how to fetch AMM pool reserves, calculate prices, and build OHLC candle data using Lua scripts with the Subfrost API. This guide covers both server-side Lua execution and client-side integration with alkanes-web-sys.",

    overviewTitle: "Overview",
    overviewDesc: "The Subfrost API provides powerful Lua scripting capabilities that allow you to batch multiple RPC calls into a single request. This is particularly useful for fetching historical pool data to build price charts and candles.",

    keyConceptsTitle: "Key Concepts",
    keyConcepts: [
      { title: "lua_evalscript", desc: "Execute Lua scripts server-side with access to all RPC methods via the _RPC global table" },
      { title: "metashrew_view", desc: "Query historical blockchain state at any block height using prebuilt protobuf payloads" },
      { title: "Pool Reserves", desc: "AMM pools store token reserves (reserve_a, reserve_b) which determine the exchange rate" },
      { title: "OHLC Candles", desc: "Open-High-Low-Close price data points aggregated over time intervals" }
    ],

    poolConfigTitle: "Pool Configuration",
    poolConfigDesc: "Each pool has a unique protobuf payload used for querying its state. These payloads are generated by the alkanes-cli and can be used directly with metashrew_view:",

    luaScriptTitle: "Lua Script for Pool Candles",
    luaScriptDesc: "This Lua script fetches pool reserves at multiple block heights and retrieves actual block timestamps from Bitcoin block headers:",

    scriptExplanationTitle: "Script Breakdown",
    scriptExplanations: [
      { section: "Arguments", desc: "The script receives pool_payload (protobuf hex), start_height, end_height, and interval as parameters" },
      { section: "parse_u128_le", desc: "Helper function to parse little-endian 128-bit integers from the hex response" },
      { section: "get_block_timestamp", desc: "Fetches the actual Unix timestamp from Bitcoin block headers using btc_getblockhash and btc_getblock" },
      { section: "metashrew_view", desc: "Queries pool state at each block height using the prebuilt protobuf payload" },
      { section: "Response Parsing", desc: "Extracts reserve_a, reserve_b, and total_supply from the protobuf-wrapped response" }
    ],

    curlExampleTitle: "Calling from curl",
    curlExampleDesc: "You can execute the Lua script directly via the JSON-RPC API:",

    jsExampleTitle: "JavaScript/TypeScript Integration",
    jsExampleDesc: "Here's how to call the Lua script from your application:",

    priceCalcTitle: "Calculating Prices",
    priceCalcDesc: "Once you have the reserves, calculate the price by adjusting for token decimals:",

    candleBuilderTitle: "Building Candles",
    candleBuilderDesc: "Aggregate price data points into OHLC candles:",

    btcPriceTitle: "Fetching Bitcoin Price",
    btcPriceDesc: "To convert token prices to USD, fetch the current Bitcoin price from the Data API:",

    dieselMetricsTitle: "DIESEL Price Metrics Example",
    dieselMetricsDesc: "Combine pool prices with BTC price to get comprehensive DIESEL metrics:",

    webSysTitle: "Using with alkanes-web-sys",
    webSysDesc: "The alkanes-web-sys package provides WASM bindings for browser and Node.js environments. The same Lua scripts work seamlessly:",

    tipsTitle: "Best Practices",
    tips: [
      "Cache historical data aggressively - past block data never changes",
      "Use intervals of 144 blocks (~1 day) for daily candles",
      "Batch multiple height queries in a single Lua script call",
      "Handle rate limits gracefully with exponential backoff",
      "Store timestamps as Unix seconds from block headers for accuracy"
    ],

    examplesTitle: "Example Lua Scripts",
    examplesDesc: "Find more Lua script examples in the public/lua-examples directory:",
    exampleScripts: [
      { name: "pool_candles.lua", desc: "Fetch pool reserves and build candle data" },
      { name: "balances.lua", desc: "Query token balances for addresses" },
      { name: "multicall.lua", desc: "Batch multiple RPC calls efficiently" },
      { name: "spendable_utxos.lua", desc: "Find spendable UTXOs for an address" }
    ],

    signupCta: "Get an API Key",
    signupDesc: "To use the Subfrost API in production, sign up for an API key at"
  },
  zh: {
    title: "使用 Lua 获取池价格和蜡烛图",
    intro: "学习如何使用 Lua 脚本通过 Subfrost API 获取 AMM 池储备、计算价格并构建 OHLC 蜡烛图数据。本指南涵盖服务器端 Lua 执行和使用 alkanes-web-sys 的客户端集成。",

    overviewTitle: "概述",
    overviewDesc: "Subfrost API 提供强大的 Lua 脚本功能，允许您将多个 RPC 调用批量处理为单个请求。这对于获取历史池数据以构建价格图表和蜡烛图特别有用。",

    keyConceptsTitle: "关键概念",
    keyConcepts: [
      { title: "lua_evalscript", desc: "在服务器端执行 Lua 脚本，通过 _RPC 全局表访问所有 RPC 方法" },
      { title: "metashrew_view", desc: "使用预构建的 protobuf 负载在任意区块高度查询历史区块链状态" },
      { title: "池储备", desc: "AMM 池存储代币储备（reserve_a，reserve_b），决定兑换率" },
      { title: "OHLC 蜡烛图", desc: "在时间间隔内聚合的开盘-最高-最低-收盘价格数据点" }
    ],

    poolConfigTitle: "池配置",
    poolConfigDesc: "每个池都有一个用于查询其状态的唯一 protobuf 负载。这些负载由 alkanes-cli 生成，可直接与 metashrew_view 一起使用：",

    luaScriptTitle: "池蜡烛图 Lua 脚本",
    luaScriptDesc: "此 Lua 脚本在多个区块高度获取池储备，并从比特币区块头获取实际区块时间戳：",

    scriptExplanationTitle: "脚本解析",
    scriptExplanations: [
      { section: "参数", desc: "脚本接收 pool_payload（protobuf 十六进制）、start_height、end_height 和 interval 作为参数" },
      { section: "parse_u128_le", desc: "从十六进制响应解析小端 128 位整数的辅助函数" },
      { section: "get_block_timestamp", desc: "使用 btc_getblockhash 和 btc_getblock 从比特币区块头获取实际 Unix 时间戳" },
      { section: "metashrew_view", desc: "使用预构建的 protobuf 负载在每个区块高度查询池状态" },
      { section: "响应解析", desc: "从 protobuf 包装的响应中提取 reserve_a、reserve_b 和 total_supply" }
    ],

    curlExampleTitle: "从 curl 调用",
    curlExampleDesc: "您可以直接通过 JSON-RPC API 执行 Lua 脚本：",

    jsExampleTitle: "JavaScript/TypeScript 集成",
    jsExampleDesc: "以下是从应用程序调用 Lua 脚本的方法：",

    priceCalcTitle: "计算价格",
    priceCalcDesc: "获得储备后，通过调整代币小数位来计算价格：",

    candleBuilderTitle: "构建蜡烛图",
    candleBuilderDesc: "将价格数据点聚合为 OHLC 蜡烛图：",

    btcPriceTitle: "获取比特币价格",
    btcPriceDesc: "要将代币价格转换为美元，从 Data API 获取当前比特币价格：",

    dieselMetricsTitle: "DIESEL 价格指标示例",
    dieselMetricsDesc: "将池价格与 BTC 价格结合，获取全面的 DIESEL 指标：",

    webSysTitle: "使用 alkanes-web-sys",
    webSysDesc: "alkanes-web-sys 包为浏览器和 Node.js 环境提供 WASM 绑定。相同的 Lua 脚本可以无缝工作：",

    tipsTitle: "最佳实践",
    tips: [
      "积极缓存历史数据 - 过去的区块数据永不改变",
      "使用 144 区块（约 1 天）的间隔作为日蜡烛图",
      "在单个 Lua 脚本调用中批量处理多个高度查询",
      "使用指数退避优雅地处理速率限制",
      "存储来自区块头的 Unix 秒时间戳以确保准确性"
    ],

    examplesTitle: "Lua 脚本示例",
    examplesDesc: "在 public/lua-examples 目录中查找更多 Lua 脚本示例：",
    exampleScripts: [
      { name: "pool_candles.lua", desc: "获取池储备并构建蜡烛图数据" },
      { name: "balances.lua", desc: "查询地址的代币余额" },
      { name: "multicall.lua", desc: "高效批量处理多个 RPC 调用" },
      { name: "spendable_utxos.lua", desc: "查找地址的可花费 UTXO" }
    ],

    signupCta: "获取 API 密钥",
    signupDesc: "要在生产环境中使用 Subfrost API，请在以下网址注册 API 密钥"
  }
};

function CodeBlock({ children, language = "lua" }: { children: string; language?: string }) {
  return (
    <pre className="p-4 rounded-lg bg-[color:var(--sf-surface)] border border-[color:var(--sf-outline)] overflow-x-auto text-sm my-4">
      <code className={`language-${language}`}>{children}</code>
    </pre>
  );
}

function Section({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <div className="mt-8">
      <h2 className="text-2xl font-semibold mb-4">{title}</h2>
      {children}
    </div>
  );
}

export default function LuaPricingPage() {
  const locale = useLocale();
  const t = content[locale as keyof typeof content] || content.en;

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold mb-4">{t.title}</h1>
        <p className="text-lg text-[color:var(--sf-muted)]">{t.intro}</p>
      </div>

      <Section title={t.overviewTitle}>
        <p className="text-[color:var(--sf-muted)]">{t.overviewDesc}</p>
      </Section>

      <Section title={t.keyConceptsTitle}>
        <div className="grid gap-4 md:grid-cols-2">
          {t.keyConcepts.map((concept, i) => (
            <div key={i} className="p-4 rounded-lg border border-[color:var(--sf-outline)]">
              <h3 className="font-semibold mb-2 font-mono text-sm">{concept.title}</h3>
              <p className="text-sm text-[color:var(--sf-muted)]">{concept.desc}</p>
            </div>
          ))}
        </div>
      </Section>

      <Section title={t.poolConfigTitle}>
        <p className="mb-4 text-[color:var(--sf-muted)]">{t.poolConfigDesc}</p>
        <CodeBlock language="javascript">{`// Pool configurations with protobuf payloads
const POOL_CONFIGS = {
  DIESEL_FRBTC: {
    id: '2:77087',
    name: 'DIESEL/frBTC',
    protobufPayload: '0x208bce382a06029fda04e7073001',
    token0Decimals: 6,  // DIESEL
    token1Decimals: 8,  // frBTC
  },
  DIESEL_BUSD: {
    id: '2:68441',
    name: 'DIESEL/bUSD',
    protobufPayload: '0x208bce382a0602d99604e7073001',
    token0Decimals: 6,  // DIESEL
    token1Decimals: 6,  // bUSD
  },
};`}</CodeBlock>
      </Section>

      <Section title={t.luaScriptTitle}>
        <p className="mb-4 text-[color:var(--sf-muted)]">{t.luaScriptDesc}</p>
        <CodeBlock>{`-- Pool candles: Fetch pool reserves at multiple block heights
-- Args: params[1]=pool_payload, params[2]=start_height, params[3]=end_height, params[4]=interval

local params = args[1] or {}
local pool_payload = params[1]
local start_height = tonumber(params[2])
local end_height = tonumber(params[3])
local interval = tonumber(params[4]) or 144  -- Default: ~1 day

if not pool_payload or not start_height or not end_height then
    return { error = "Missing required arguments" }
end

-- Helper to parse little-endian u128 from hex string
local function parse_u128_le(hex_str, byte_offset)
    local hex_offset = byte_offset * 2
    local hex_len = 32  -- 16 bytes = 32 hex chars
    if #hex_str < hex_offset + hex_len then return nil end

    local hex_slice = hex_str:sub(hex_offset + 1, hex_offset + hex_len)
    local reversed = ""
    for i = #hex_slice - 1, 1, -2 do
        reversed = reversed .. hex_slice:sub(i, i + 1)
    end
    return tonumber(reversed, 16) or 0
end

-- Get actual block timestamp from Bitcoin block header
local function get_block_timestamp(height)
    local success, block_hash = pcall(function()
        return _RPC.btc_getblockhash(height)
    end)
    if not success or not block_hash then return nil end

    local success2, block = pcall(function()
        return _RPC.btc_getblock(block_hash, 1)
    end)
    if not success2 or not block then return nil end

    return block.time or block.mediantime
end

local results = { data_points = {} }

-- Query pool state at each interval
for height = start_height, end_height, interval do
    local block_tag = tostring(height)
    local success, response = pcall(function()
        return _RPC.metashrew_view("simulate", pool_payload, block_tag)
    end)

    if success and response and type(response) == "string" then
        local data_hex = response
        if data_hex:sub(1, 2) == "0x" then
            data_hex = data_hex:sub(3)
        end

        -- Find inner data after protobuf wrapper
        local marker_pos = data_hex:find("1a")
        if marker_pos then
            local len_byte = tonumber(data_hex:sub(marker_pos + 2, marker_pos + 3), 16) or 0
            local inner_start = marker_pos + (len_byte < 128 and 4 or 6)

            if #data_hex >= inner_start + 223 then
                local inner_hex = data_hex:sub(inner_start)

                -- Parse reserves (at byte offsets 64, 80, 96)
                local reserve_a = parse_u128_le(inner_hex, 64)
                local reserve_b = parse_u128_le(inner_hex, 80)
                local total_supply = parse_u128_le(inner_hex, 96)

                if reserve_a and reserve_b and total_supply then
                    local timestamp = get_block_timestamp(height)

                    table.insert(results.data_points, {
                        height = height,
                        timestamp = timestamp,
                        reserve_a = reserve_a,
                        reserve_b = reserve_b,
                        total_supply = total_supply
                    })
                end
            end
        end
    end
end

results.count = #results.data_points
return results`}</CodeBlock>
      </Section>

      <Section title={t.scriptExplanationTitle}>
        <div className="space-y-3">
          {t.scriptExplanations.map((item, i) => (
            <div key={i} className="flex gap-4">
              <span className="font-mono text-sm font-semibold min-w-[140px]">{item.section}</span>
              <span className="text-[color:var(--sf-muted)]">{item.desc}</span>
            </div>
          ))}
        </div>
      </Section>

      <Section title={t.curlExampleTitle}>
        <p className="mb-4 text-[color:var(--sf-muted)]">{t.curlExampleDesc}</p>
        <CodeBlock language="bash">{`curl -X POST https://mainnet.subfrost.io/v4/jsonrpc \\
  -H "Content-Type: application/json" \\
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "lua_evalscript",
    "params": [
      "<lua_script_here>",
      ["0x208bce382a06029fda04e7073001", "920000", "927000", "144"]
    ]
  }'

# Response structure:
{
  "jsonrpc": "2.0",
  "result": {
    "calls": 56,
    "returns": {
      "data_points": [
        { "height": 920000, "timestamp": 1733000000, "reserve_a": 1000000, "reserve_b": 50000000 },
        ...
      ],
      "count": 8
    },
    "runtime": 1234
  },
  "id": 1
}`}</CodeBlock>
      </Section>

      <Section title={t.jsExampleTitle}>
        <p className="mb-4 text-[color:var(--sf-muted)]">{t.jsExampleDesc}</p>
        <CodeBlock language="typescript">{`const RPC_URL = 'https://mainnet.subfrost.io/v4/jsonrpc';

// Or with your API key:
// const RPC_URL = 'https://mainnet.subfrost.io/v4/YOUR_API_KEY';

interface PoolDataPoint {
  height: number;
  timestamp?: number;
  reserve0: bigint;
  reserve1: bigint;
  totalSupply: bigint;
}

async function fetchPoolDataPoints(
  poolPayload: string,
  startHeight: number,
  endHeight: number,
  interval: number = 144
): Promise<PoolDataPoint[]> {
  const response = await fetch(RPC_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method: 'lua_evalscript',
      params: [
        POOL_CANDLES_LUA_SCRIPT,
        [poolPayload, startHeight.toString(), endHeight.toString(), interval.toString()],
      ],
    }),
  });

  const json = await response.json();

  // lua_evalscript returns { calls, returns, runtime }
  const luaResult = json.result?.returns;

  if (luaResult?.error) {
    throw new Error(\`Lua script error: \${luaResult.error}\`);
  }

  const dataPoints = luaResult?.data_points || [];
  return dataPoints.map(dp => ({
    height: dp.height,
    timestamp: dp.timestamp,
    reserve0: BigInt(Math.floor(dp.reserve_a)),
    reserve1: BigInt(Math.floor(dp.reserve_b)),
    totalSupply: BigInt(Math.floor(dp.total_supply)),
  }));
}`}</CodeBlock>
      </Section>

      <Section title={t.priceCalcTitle}>
        <p className="mb-4 text-[color:var(--sf-muted)]">{t.priceCalcDesc}</p>
        <CodeBlock language="typescript">{`function calculatePrice(
  reserve0: bigint,
  reserve1: bigint,
  decimals0: number,
  decimals1: number
): number {
  if (reserve0 === BigInt(0)) return 0;

  // Adjust for decimal places
  const adjusted0 = Number(reserve0) / Math.pow(10, decimals0);
  const adjusted1 = Number(reserve1) / Math.pow(10, decimals1);

  // Price = reserve1 / reserve0 (how much token1 per token0)
  return adjusted1 / adjusted0;
}

// Example: DIESEL/frBTC pool
const price = calculatePrice(
  BigInt("1000000000"),  // 1000 DIESEL (6 decimals)
  BigInt("50000000"),    // 0.5 frBTC (8 decimals)
  6,  // DIESEL decimals
  8   // frBTC decimals
);
// price = 0.0000005 frBTC per DIESEL`}</CodeBlock>
      </Section>

      <Section title={t.candleBuilderTitle}>
        <p className="mb-4 text-[color:var(--sf-muted)]">{t.candleBuilderDesc}</p>
        <CodeBlock language="typescript">{`interface Candle {
  timestamp: number;  // Unix milliseconds
  open: number;
  high: number;
  low: number;
  close: number;
}

function buildCandles(
  dataPoints: PoolDataPoint[],
  decimals0: number,
  decimals1: number,
  candleBlocks: number = 144
): Candle[] {
  if (dataPoints.length === 0) return [];

  const sorted = [...dataPoints].sort((a, b) => a.height - b.height);
  const candles: Candle[] = [];

  let candleStartBlock = sorted[0].height;
  let candleStartTimestamp = sorted[0].timestamp
    ? sorted[0].timestamp * 1000
    : Date.now();
  let candlePrices: number[] = [];

  for (const dp of sorted) {
    const price = calculatePrice(dp.reserve0, dp.reserve1, decimals0, decimals1);

    if (dp.height >= candleStartBlock + candleBlocks) {
      // Close current candle
      if (candlePrices.length > 0) {
        candles.push({
          timestamp: candleStartTimestamp,
          open: candlePrices[0],
          high: Math.max(...candlePrices),
          low: Math.min(...candlePrices),
          close: candlePrices[candlePrices.length - 1],
        });
      }

      // Start new candle
      candleStartBlock = Math.floor(dp.height / candleBlocks) * candleBlocks;
      candleStartTimestamp = dp.timestamp ? dp.timestamp * 1000 : Date.now();
      candlePrices = [price];
    } else {
      candlePrices.push(price);
    }
  }

  // Don't forget the last candle
  if (candlePrices.length > 0) {
    candles.push({
      timestamp: candleStartTimestamp,
      open: candlePrices[0],
      high: Math.max(...candlePrices),
      low: Math.min(...candlePrices),
      close: candlePrices[candlePrices.length - 1],
    });
  }

  return candles;
}`}</CodeBlock>
      </Section>

      <Section title={t.btcPriceTitle}>
        <p className="mb-4 text-[color:var(--sf-muted)]">{t.btcPriceDesc}</p>
        <CodeBlock language="typescript">{`const DATA_API_URL = 'https://mainnet.subfrost.io/v4/api';

// Or with your API key:
// const DATA_API_URL = 'https://mainnet.subfrost.io/v4/YOUR_API_KEY';

interface BitcoinPrice {
  usd: number;
  timestamp: number;
}

async function fetchBitcoinPrice(): Promise<BitcoinPrice> {
  const response = await fetch(\`\${DATA_API_URL}/get-bitcoin-price\`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({}),
  });

  const json = await response.json();

  // Response: { statusCode: 200, data: { bitcoin: { usd: 92310.54 } } }
  const usd = json.data?.bitcoin?.usd;

  if (typeof usd !== 'number') {
    throw new Error('Invalid BTC price response');
  }

  return { usd, timestamp: Date.now() };
}

// Usage
const btcPrice = await fetchBitcoinPrice();
console.log(\`BTC: $\${btcPrice.usd.toLocaleString()}\`);`}</CodeBlock>
      </Section>

      <Section title={t.dieselMetricsTitle}>
        <p className="mb-4 text-[color:var(--sf-muted)]">{t.dieselMetricsDesc}</p>
        <CodeBlock language="typescript">{`interface DieselPriceMetrics {
  dieselFrbtcPrice: number;   // DIESEL in frBTC
  dieselBusdPrice: number;    // DIESEL in bUSD
  btcUsdPrice: number;        // BTC in USD
  dieselUsdViaFrbtc: number;  // DIESEL in USD (calculated)
  timestamp: number;
}

async function getDieselMetrics(): Promise<DieselPriceMetrics> {
  // 1. Get current block height
  const heightResponse = await fetch(RPC_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0', id: 1, method: 'metashrew_height', params: []
    }),
  });
  const currentHeight = parseInt((await heightResponse.json()).result, 10);

  // 2. Fetch pool data for both pools (in parallel)
  const [frbtcData, busdData, btcPrice] = await Promise.all([
    fetchPoolDataPoints(POOL_CONFIGS.DIESEL_FRBTC.protobufPayload, currentHeight, currentHeight, 1),
    fetchPoolDataPoints(POOL_CONFIGS.DIESEL_BUSD.protobufPayload, currentHeight, currentHeight, 1),
    fetchBitcoinPrice(),
  ]);

  // 3. Calculate prices
  const dieselFrbtcPrice = calculatePrice(
    frbtcData[0].reserve0, frbtcData[0].reserve1, 6, 8
  );
  const dieselBusdPrice = calculatePrice(
    busdData[0].reserve0, busdData[0].reserve1, 6, 6
  );

  // 4. Calculate DIESEL/USD via frBTC
  // frBTC is 1:1 with BTC, so: DIESEL/frBTC * BTC/USD = DIESEL/USD
  const dieselUsdViaFrbtc = dieselFrbtcPrice * btcPrice.usd;

  return {
    dieselFrbtcPrice,
    dieselBusdPrice,
    btcUsdPrice: btcPrice.usd,
    dieselUsdViaFrbtc,
    timestamp: Date.now(),
  };
}

// Usage
const metrics = await getDieselMetrics();
console.log(\`DIESEL/frBTC: \${metrics.dieselFrbtcPrice.toFixed(8)}\`);
console.log(\`DIESEL/bUSD:  \${metrics.dieselBusdPrice.toFixed(4)}\`);
console.log(\`BTC/USD:      $\${metrics.btcUsdPrice.toLocaleString()}\`);
console.log(\`DIESEL/USD:   $\${metrics.dieselUsdViaFrbtc.toFixed(4)}\`);`}</CodeBlock>
      </Section>

      <Section title={t.tipsTitle}>
        <ul className="list-disc list-inside space-y-2 text-[color:var(--sf-muted)]">
          {t.tips.map((tip, i) => (
            <li key={i}>{tip}</li>
          ))}
        </ul>
      </Section>

      <Section title={t.examplesTitle}>
        <p className="mb-4 text-[color:var(--sf-muted)]">{t.examplesDesc}</p>
        <div className="overflow-x-auto">
          <table className="w-full border-collapse text-sm">
            <thead>
              <tr className="border-b border-[color:var(--sf-outline)]">
                <th className="text-left py-2 px-3">Script</th>
                <th className="text-left py-2 px-3">Description</th>
              </tr>
            </thead>
            <tbody>
              {t.exampleScripts.map((script, i) => (
                <tr key={i} className="border-b border-[color:var(--sf-outline)]">
                  <td className="py-2 px-3 font-mono">{script.name}</td>
                  <td className="py-2 px-3 text-[color:var(--sf-muted)]">{script.desc}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </Section>

      <div className="mt-12 p-6 rounded-lg bg-[color:var(--sf-surface)] border border-[color:var(--sf-outline)]">
        <h3 className="text-xl font-semibold mb-2">{t.signupCta}</h3>
        <p className="text-[color:var(--sf-muted)]">
          {t.signupDesc}{" "}
          <a
            href="https://api.subfrost.io"
            target="_blank"
            rel="noopener noreferrer"
            className="text-[color:var(--sf-primary)] hover:underline"
          >
            api.subfrost.io
          </a>
        </p>
      </div>
    </div>
  );
}
